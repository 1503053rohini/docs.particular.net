---
title: SQL Server Transport configuration
summary: SQLServer transport configuration
tags:
- SQL Server
---

## Connection strings

Connection string can be configured in several ways


### Via the App.Config

By adding a connection named `NServiceBus/Transport` in the `connectionStrings` node.
  
```xml
<connectionStrings>
   <!-- SQL Server -->
   <add name="NServiceBus/Transport"
        connectionString="Data Source=.\SQLEXPRESS;
                                      Initial Catalog=nservicebus;
                                      Integrated Security=True"/>
</connectionStrings>
```


### Via the configuration API

By using the `ConnectionString` extension method.

snippet:sqlserver-config-connectionstring


### Via a named connection string

By using the `ConnectionStringName` extension method.

snippet:sqlserver-named-connection-string

Combined with a named connection in the `connectionStrings` node of you `app.config`.

snippet:sqlserver-named-connection-string-xml

## Sql Server Transport, the Outbox and user data: disabling the DTC

When dealing with database connections in an environment where we do not want to use DTC it is important to prevent a local transaction from escalating to a distributed one.

The following are required:

* the business specific data and the `Outbox` storage must be in the same database;
* the user code accessing business related data must use the same `connection string` as the `Outbox` storage;


## Persistence

In theory there is nothing that prevents usage of RavenDB persistence in conjunction with the SQL Server transport but the most common and natural scenario is combination of SQL Server transport and NHibernate persistence. The rest of the article is based on this assumption.

### [Entity Framework](https://msdn.microsoft.com/en-us/data/ef.aspx) caveats

Sharing the same connection string is easy when you have full control over the creation of the underlying `SQL connection`, but it can be problematic when dealing with entities based on the [Entity Framework ADO.Net Data Model (EDMX)](https://msdn.microsoft.com/en-us/library/vstudio/cc716685.aspx).

The `DbContext` generated by Entity Framework does not expose a way to inject a simple database connection string; the underlying problem is that Entity Framework requires an `Entity Connection String` that has much more information than a simple connection string.

It is possible to generate a custom a custom `EntityConnection` and inject it into the Entity Framework `DbContext` instance:

snippet:EntityConnectionCreationAndUsage

In the above snippet you are using `EntityConnectionStringBuilder` class to create a valid `Entity Connection String`, once you have that you can create a new `EntityConnection` instance.
The `DbContext` generated by default by Entity Framework does not have a constructor that accepts an `EntityConnection` as a parameter but since it is a partial class you can easily add one:

snippet:DbContextPartialWithEntityConnection

NOTE: The above snippets assumes that the created entity data model is named `MySample`, change all the reference to match your project conventions.


## Transactions

The SQL Server transport can work in three modes with regards to transactions. These modes are enabled based on the bus configurations:


### Ambient transaction

The ambient transaction mode is selected by default. It relies or `Transactions.Enabled` setting being set to `true` and `Transactions.SuppressDistributedTransactions` being set to false. One needs to only select the transport:

snippet:sqlserver-config-transactionscope

When in this mode, the receive operation is wrapped in a `TransactionScope` together with the message processing in the pipeline. This means that usage of any other persistent resource manager (e.g. RavenDB client, another `SqlConnection` with different connection string) will cause escalation of the transaction to full two-phase commit protocol handled via Distributed Transaction Coordinator (MS DTC).


### Controlling transaction scope options

The following transaction scope options can be configured when the SQL Server transport is working in the ambient transaction mode.


### Isolation level

NServiceBus will by default use the `ReadCommitted` [isolation level](https://msdn.microsoft.com/en-us/library/system.transactions.isolationlevel).

Change the isolation level using

snippet:sqlserver-config-transactionscope-isolation-level


### Transaction timeout

NServiceBus will use the [default transaction timeout](https://msdn.microsoft.com/en-us/library/system.transactions.transactionmanager.defaulttimeout) of the machine the endpoint is running on.

Change the transaction timeout using

snippet:sqlserver-config-transactionscope-timeout

Or via .config file using a [example DefaultSettingsSection](https://msdn.microsoft.com/en-us/library/system.transactions.configuration.defaultsettingssection.aspx#Anchor_5).


### Native transaction

The native transaction mode requires both `Transactions.Enabled` and `Transactions.SuppressDistributedTransactions` to be set to `true`. It can be selected via

snippet:sqlserver-config-native-transactions

When in this mode, the receive operation is wrapped in a plain ADO.NET `SqlTransaction`. Both connection and the transaction instances are attached to the pipeline context under these keys `SqlConnection-{ConnectionString}` and `SqlTransaction-{ConnectionString}` and are available for user code so that the updates to user data can be done atomically with queue receive operation.


### No transaction

The no transaction mode requires `Transactions.Enabled` to be set to false which can be achieved via following API call:

snippet:sqlserver-config-no-transactions

When in this mode, the receive operation is not wrapped in any transaction so it is executed by the SQL Server in its own implicit transaction.

WARNING: This means that as soon as the `DELETE` operation used for receiving completes, the message is gone and any exception that happens during processing of this message causes it to be permanently lost.



## Callbacks

### Disable callbacks

Secondary queues (callbacks) are enabled by default. In order to disable them, one must use the configuration API:

snippet:sqlserver-config-disable-secondaries

Secondary queues use same adaptive concurrency model to the primary queue. Secondary queues (and hence callbacks) are disabled for satellite receivers.


### Callback Receiver Max Concurrency

Changes the number of threads that should be used for the callback receiver. The default is 1 thread.

snippet:sqlserver-CallbackReceiverMaxConcurrency


## Circuit Breaker

The Sql transport has a built in circuit breaker to handle intermittent Sql connectivity problems.


### Wait time

Overrides the default time to wait before triggering a circuit breaker that initiates the endpoint shutdown procedure in case there are numerous errors while trying to receive messages.

The default is 2 minutes.

snippet:sqlserver-TimeToWaitBeforeTriggeringCircuitBreaker


### Pause Time

Overrides the default time to pause after a failure while trying to receive a message.

The default is 10 seconds.

snippet: sqlserver-PauseAfterReceiveFailure


