---
title: Using ServiceMatrix Generated Code
summary: Using ServiceMatrix and extending it with your own code. 
tags:
- ServiceMatrix
- Code Generation

---
ServiceMatrix accelerates the creation of a distributed NServiceBus solution.  As the canvas and visual elements are used to design the system the Visual Studio solution is updated with generated code and content that is automatically generated.   

This article explores how to customize the ServiceMatrix solution and add your own code.

1. [Introduction](#introduction)
2. [Message Definitions](#message-definitions)
3. [NServiceBus Components](#customizing-components)
4. [Partial Classes and Methods](#the-dynamic-partial-class)
4. [Reviewing Generated Code](#reviewing-the-generated-code)
5. [Auto Publish](#the-auto-publish-property)
6. [Sagas](#customizing-sagas)
7. [Saga Data](#saga-data)
8. [Saga Message Handlers](#saga-message-handlers)
9. [Custom Saga Finding](#custom-saga-finding-logic)
10. [Summary](#summary)

#Introduction
ServiceMatrix is a visual design tool that accelerates the design and coding of an NServiceBus system.  It generates code and automates the creation of classes, projects and configurations that would take much longer if done manually.  The generated code is designed in a way that allows for user modification and extension. This article reviews this high level design and demonstrates the extension points.    

##Viewing The Code
**NOTE**: In ServiceMatrix, to view the code for any of the components, use the drop-down within that component on the design canvas and choose `View Code`. To view related partial class definitions, put your cursor in the class name, right mouse-click and select `Go to Definition` or hit `F12`.

#Message Definitions
NServiceBus messages are plain old CLR classes in C#. As you send commands or publish events in ServiceMatrix, you are prompted only for a name. When you build your solution, the messages are generated.  The generated message classes don't contain any properties but you can easily add them. To modify a message class, [view the code](#viewing-the-code) and add whatever properties you wish.
```C#
namespace OnlineSales.InternalMessages.Commands.Sales
{
    public class SubmitOrder
    {
        public string CustomerName { get; set; }
        public string AccountNumber { get; set; }
        public string ShippingChoice { get; set; }
    }
}
``` 
If you build the solution again, the new message properties will be available in the components, handlers and sagas.  Since the message classes are only generated one time by ServiceMatrix, they are safe to edit.

#Customizing Components
Mixing dynamic code and user created code can be challenging.  This is especially true in an environment like ServiceMatrix where as you continue to design your system in the visual environment code is regenerated. This must be done without disturbing the users code that has been added along the way.   

##Partial Classes and Partial Methods
To solve this, the design of the generated code uses partial classes.  The dynamic files that are subject to regeneration by ServiceMatrix are created with a partial class definition in one file.  The same partial class is also defined in a separate file that is for user customization. Generated code in one file invokes virtual methods that are further defined in the user modified partial class. 

The dynamic partial class includes straight forward message handlers and partial methods.  This file should not be edited and warns you of this in the comments at the top of the file.  It will be regenerated every time the ServiceMatrix solution is built and will change as the visual design or settings are modified. 

```C#
//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by ServiceMatrix.
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
```
##Reviewing The Generated Code 
The design of the generated message handlers use partial methods to provide opportunities for the modification of messages and the integration of your own code and services.  Lets look at the code for a sample component. 

##NServiceBus Component Code 
The code below was generated by ServiceMatrix for component that handles a `SubmitOrder` message and publishes a `Orderaccepted` event that looks like this on the canvas. 

![SubmitOrderProcessing Component](images/servicematrix-orderprocessing.png)

###The Dynamic Partial Class
The dynamic code generator has created a handler for the `SubmitOrder` method.  In the handler a  `HandleImplementation` partial method for the message is invoked.  As a partial method, it is stubbed out in one class but implemented separately in the other partial class file.  The `Bus` property  provides a handle to the `Bus` object. 

```C#
namespace OnlineSales.Sales
{
    public partial class SubmitOrderProcessor : IHandleMessages<SubmitOrder>
    {
		public void Handle(SubmitOrder message)
		{
			// Handle message on partial class
			this.HandleImplementation(message);
		}

		partial void HandleImplementation(SubmitOrder message);

        public IBus Bus { get; set; }
    }
}
```
###The Customizable Partial Class 
The customizable partial class is generated by ServiceMatrix and is intended to be modified with partial methods and custom logic.  This class is generated only one time.  After adding elements to your design in ServiceMatrix, this code is generated only the first time you build your solution.  It will contain a partial method for each the message types it handles and a publish or send method for any outbound messages.    

```C#
namespace OnlineSales.Sales
{
    public partial class SubmitOrderProcessor
    {
        partial void HandleImplementation(SubmitOrder message)
        {
            // TODO: SubmitOrderProcessor: Add code to handle the SubmitOrder message.
            Console.WriteLine("Sales received " + message.GetType().Name);

            // Auto-publish Event OrderAccepted
            var OrderAccepted = new OnlineSales.Contracts.Sales.OrderAccepted();
            this.Bus.Publish(OrderAccepted);
        }
    }
}
```
**Handlers**
In the example above, the code generator has stubbed out a simple implemention of the partial `HandleImplementation` method for the  `SubmitOrder` command message.  This is the place to put custom handler code.  
**Outbound Messages**
In the example above the code generator has also created the code to instantiate a new `OrderAccepted` event and publish it using the bus automatically when the the `SubmitOrder` message is handled. The comments indicate this code was generated by ServiceMatrix 
##Adding Messages to the Design
The code generator will create code for handlers and sending any messages that are in your design *the first time you build the solution*.  In the sample above, the code for handling the `SubmitOrder` message and publishing the `OrderAccepted` event was created because both of them were designed in ServiceMatrix at initial build. 
 
As you continue to added to your design the code generator after the initial build, ServiceMatrix cannot safely edit the partial class definition or custom code could be impacted.  When you add additional messages to a component, ServiceMatrix will recognize that new code is needed and warn you as shown:

![User Code Changes Required](images/servicematrix-codechangerequired.png) 

Adding a new `HightPriorityOrderAccepted` event to the example above causes ServiceMatrix to prompt with the code required to create and publish the message.  ServiceMatrix can assist you by opening the partial class file and placing the code on the clipboard so you can easily add it.  

#Understanding Saga Code
ServiceMatrix supports the design of [NServiceBus sagas](images/sagas-in-nservicebus.md "Sagas in NserviceBus") and generates the necessary code to get you started.  The saga is a specialized stateful version of a ServiceMatrix component.  As we reviewed above, the dynamic code and user modified code are in separate partial class files.  For sagas, the design has been extended to to include definitions for saga data, custom finding logic, and some convenience methods to make saga completion easier.  

The code below is based on a saga designed in ServiceMatrix that correlates the request and response with another endpoint as shown.  This saga handles the `OrderAccepted` event then publishes the `SubmitPayment` request to a payment processing service.  The saga also handles and correlates the `SubmitPaymentResponse`.

![Billing Saga](images/servicematrix-billingsagaandpaymntcanvas.png)

##Designating the Startup Messages
Depending on the design, one or more messages can start a saga.  If the saga is handling multiple messages, you will be [prompted in ServiceMatrix](images/servicematrix-sagastarter.png "Designated Saga Starters") to indicate which messages will start the saga.  The partial class that contains the component definition will be generated to extent the NServiceBus.Saga base class and will use the marker interfaces to indicate the start-up message types and the message types that the saga will handle.  

The code below is generated for example saga class above.  Once again, this is dynamic code that will be regenerated so it is not safe to edit it.   

```C#
namespace OnlineSales.Billing
{
    public partial class OrderAcceptedProcessor : Saga<OrderAcceptedProcessorSagaData>, IOrderAcceptedProcessor, ServiceMatrix.Shared.INServiceBusComponent, IAmStartedByMessages<OrderAccepted>, IHandleMessages<SubmitPaymentResponse>
    {
		public void Handle(OrderAccepted message)
		{
			......
```

##Saga Data
The Saga data is implemented as a partial class in the same dynamic file as the saga itself. The generated saga data design includes default properties for a unique ID and the storage of any message that is handled.  It also stores information about the `Originator` of the message that started the saga and the Id of that message. 
```C#

public partial class OrderAcceptedProcessorSagaData : IContainSagaData
     {
           public virtual Guid Id { get; set; }
           public virtual string Originator { get; set; }
           public virtual string OriginalMessageId { get; set; }
           public virtual OrderAccepted OrderAccepted { get; set; }
           public virtual SubmitPaymentResponse SubmitPaymentResponse { get; set; }
    }
```
As you've seen, this file is dynamic and cannot be edited.  A separate file contains a partial class for the saga data.  It provides a place to add your own properties.  Notice how the example uses the OrderID as the unique identifier for the saga data and marks is with the `[Unique]` attribute.

```C#
namespace OnlineSales.Billing
{
    public partial class OrderAcceptedProcessorSagaData
    {
        [Unique]
        public Guid OrderID { get; set; }
        public string PaymentAuthorizationCode { get; set; }
    }
}
```
##Saga Message Handlers
The message handling code of the Saga is implemented very much like the [component code above](#nservicebus-component-code).  The code will implement a handler in the saga for the messages handled in the ServiceMatrix design.  

The [Auto Publish Messages](#the-auto-publish-property) property to `True` for sagas.  Sagas are often used to maintain state and correlate multiple messages arriving at different times before sending or sending an outbound message.  In these scenarios Auto Publish should be set to `False`.
  
The following sample customizes the saga code.  It handles an `OrderAccepted` event, stores the `OrderID` then creates and sends the `SubmitPayment` command.  The saga then handles the `SubmitPaymentResponse` message and stores the `PaymentAuthorizationCode` in the saga data.

```C#
namespace OnlineSales.Billing
{
    public partial class OrderAcceptedProcessor
    {
        partial void HandleImplementation(OrderAccepted message)
        {
            Console.WriteLine("Billing received " + message.GetType().Name);
            //Customized to set the OrderID in saga data. 
            Data.OrderID = message.OrderID;
            //Since Auto Publish is off in my example, I'll send my own SubmitPayment
            var submitpayment = new InternalMessages.Commands.Billing.SubmitPayment() {ReferenceNumber=message.OrderID,Account=message.BillingAccount };
            Bus.Send(submitpayment);
         }

        partial void HandleImplementation(InternalMessages.Billing.SubmitPaymentResponse message)
        {
            //Handle the SubmitPaymentResponse
            Console.WriteLine("Billing received " + message.GetType().Name);
            //We can put response information in Saga date if needed. 
            Data.PaymentAuthorizationCode = message.AuthorizationCode;
        }

        partial void AllMessagesReceived()
        {
            Console.WriteLine("All messages received.  Completing the Saga.");
            MarkAsComplete();
        }
    }
}
``` 
The `AllMessagesReceived` is a convenient partial method.  As part of the dynamically generated handler code, every inbound message is stored in saga data. After each message is handled the saga data is checked to see if all the messages have been received.  If so, the virtual method `AllMessagesReceived` is called.  The example uses it to mark the saga as complete.

##Custom Saga Finding Logic
When a saga handles a message it must be able to correlate that message to a unique saga.  ServiceMatrix generates default code for this but if your design requires it, it can be modified.  In the [drop-down menu ](images/servicematrix-configuresaga.png)for the saga component is an option for `Configure Saga`. The provided partial class overrides the `ConfigureHowToFindSaga` method.  The comments indicate how it can be modified for any specific situation. 
```C#
amespace OnlineSales.Billing
{
    public partial class OrderAcceptedProcessor
    {
        public override void ConfigureHowToFindSaga()
        {
           // ConfigureMapping<SubmitPaymentResponse>(m => /* specify message property */).ToSaga(s =>  /* specify saga property */ );
           // If you add new messages to be handled by your saga, you will need to manually add a call to ConfigureMapping for them.
        }
    }
}

```
#Summary
The visual design environment of ServiceMatrix generates code designed to be extensible.  This article reviewed the partial classes and methods that can be customized.  

      