---
title: Extending ServiceMatrix with Custom Code
summary: Modifying ServiceMatrix and extending it with your own code. 
tags:
- ServiceMatrix
- Code Generation

---
ServiceMatrix accelerates the creation of a distributed NServiceBus solution.  As the canvas and visual elements are used to design the system the Visual Studio solution is updated with generated code and content that is automatically generated.   

This article explores how to customize the ServiceMatrix solution and add your own code.

1. [Introduction](#introduction)
2. [Partial Classes and Partial Methods](#partial-classes-and-partial-methods)
3. [Customizing Messages](#customizing-messages)



#Introduction
ServiceMatrix generates code and automates the creation of classes, projects and configurations that would take much longer if done manually.  The generated code offers a great boost to productivity and is also created in a way that allows your specific design needs to be implemented.   

#Customizing Message Definitions
Creating new messages is very easy in ServiceMatrix.  As you send commands or publish events you are prompted only for a name and ServiceMatrix does the rest.  When you build your solution, the messages are generated as regular .NET classes.  However, if you look at the generated classes you will see they don't contain any properties.  In reality of course, messages and events are critical to defining contracts between services and components.  Additionally, properties play a key role in allowing messages to be correlated with one another.  

To modify a message, view the code and add whatever properties you wish.

```C#
namespace OnlineSales.InternalMessages.Commands.Sales
{
    public class SubmitOrder
    {
        public string CustomerName { get; set; }
        public string AccountNumber { get; set; }
        public string ShippingChoice { get; set; }
    }
}
``` 
If you build the solution again, the new message properties will be available in the components, handlers and sagas. 

#Customizing Components
Mixing dynamic code and user created code can be challenging.  This is especially true in an environment like ServiceMatrix where as you continue to design your system in the visual environment code is regenerated. This must be done without disturbing the users code that has been added along the way.   

##Partial Classes and Partial Methods
To solve this, the design of the generated code uses partial classes.  The dynamic files that are subject to regeneration by ServiceMatrix are created with a partial class definition in one file.  The same partial class is further defined in a separate file that is for user customization. The generated partial class contains code that invokes user code in the the other partial class through the use of partial methods. Let's see how this works.   

The dynamic partial class uses a design that includes the received message handlers, message publishing code, and various convenience methods into the  class file.  This file should not be edited and warns you of this in the comments at the top of the file.  It will be regenerated every time the ServiceMatrix solution is built and will change as the visual design or settings are modified. 

```C#
//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by ServiceMatrix.
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
```
##Reviewing The Generated Code 
The design of the generated message handlers use partial methods to provide opportunities for the modification of messages and the integration of your own code and services.  To see how the design of these supports customization lets look at an example component. 

##Component Code 
The code below was generated by ServiceMatrix for component that handles a `SubmitOrder` message and publishes a `Orderaccepted` event that looks like this on the canvas. 

![SubmitOrderProcessing Component](images/servicematrix-orderprocessing.png)

###The Dynamic Partial Class
In dynamic code creates a handler for the `SubmitOrder` method.  In that method a  `HandleImplementation` partial method for the message is invoked. Similarly the `ConfigureOrderAccepted` partial method is invoked and passed the handled `SubmitOrder` message and a newly created `OrderAccepted` event message just before the event is automatically published on the bus.   These methods are stubbed out in this class but implemented separately in the other partial class file.  

```C#
namespace OnlineSales.Sales
{
    public partial class SubmitOrderProcessor : ISubmitOrderProcessor, ServiceMatrix.Shared.INServiceBusComponent, IHandleMessages<SubmitOrder>
    {
		public void Handle(SubmitOrder message)
		{
			// Handle message on partial class
			this.HandleImplementation(message);

			// Auto-publish Event OrderAccepted
			var OrderAccepted = new OnlineSales.Contracts.Sales.OrderAccepted();
			ConfigureOrderAccepted(message, OrderAccepted);
			this.Bus.Publish(OrderAccepted);
		}
		partial void HandleImplementation(SubmitOrder message);

		partial void ConfigureOrderAccepted(SubmitOrder incomingMessage, OnlineSales.Contracts.Sales.OrderAccepted message);

        public IBus Bus { get; set; }
    }

```
###Customizable Partial Class 
The customizable partial class is generated only once and is intended for user modification.  When generated, it will contain a partial method for the message type it handles.  Notice how the partial class continues the class definition in the dynamic partial class above. 

```C#
namespace OnlineSales.Sales
{
    public partial class SubmitOrderProcessor
    {
		
        partial void HandleImplementation(SubmitOrder message)
        {
            // TODO: SubmitOrderProcessor: Add code to handle the SubmitOrder message.
            Console.WriteLine("Sales received " + message.GetType().Name);
        }

    }
}
```
The code generator has implemented the first partial method for the `SubmitOrder` command message.  This can be used to access the properties of the message and change them with your own code.  

Notice that the other partial method, `ConfigureOrderAccepted`, has not been generated.  This method provides the opportunity to pass information from the handled message to the event.  In must be implemented manually.  Since it has been defined initially in the generated partial class, you will get Intellisense to assist you when typing it.  

```C#
partial void ConfigureOrderAccepted(SubmitOrder incomingMessage, Contracts.Sales.OrderAccepted message)
        {
            /*This method is given access to the handled message and the outbound message. You can transfer contents, implement logic,  or use your own code to integrate with other systems as your design dictates.
			*/ 
			message.OrderID = incomingMessage.OrderNumber;
		
			//The OrderAccepted is automatically publish by the caller to this method if 'Auto Publish Messages' is set to 'True' in ServiceMatrix
		}
```

## The Auto Publish Property
NServiceBus components can both handle and send or publish messages. ServiceMatrix generates component code based on the designs and settings you implement.   The `Auto Publish Messages` setting of a component controls whether a generated message handler will contain code to automatically create and publish events related to the component.  

![Component Auto Publish.](images/servicematrix-componentproperties.png)

Auto-Publish is set to 'True' by default.  In the sample above, upon receiving the `SubmitOrder` message, the generated code creates and publishes the `OrderAccepted` event using the Bus.Publish function.   It's worth noting that the `SubmitOrderProcessor` component is designed to publish an event.  If instead it was designed to reply to a sender in a full-duplex pattern, Auto-Publish would use a **Bus.Reply**   

 If you set Auto Publish to false and rebuild the solution the dynamic partial class will be re-generated.  The message handler will no longer contain the auto publish code.  Also missing would be the partial method `ConfigureOrderAccepted` that allows user code to modify message.

The user code can now be modified to create and publish the event in the existing partial method `HandleSubmitOrder` as shown here:
```C#
public partial class SubmitOrderProcessor
    {
	 partial void HandleImplementation(SubmitOrder message)
        {
            // TODO: SubmitOrderProcessor: Add code to handle the SubmitOrder message.
            Console.WriteLine("Sales received " + message.GetType().Name);

            if (message.AccountNumber != null)
            {
                var orderaccepted = new Contracts.Sales.OrderAccepted();
                Bus.Publish(orderaccepted);
             }
		}
      }
```
As you would expect, the custom code allows for more control of the process.
 
 



 
 